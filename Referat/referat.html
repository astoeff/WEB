<!DOCTYPE html>
<html>
<head>
	<title>Софтуерни шаблони. Структурни шаблони в PHP</title>
	<link href="css\style.css" rel="stylesheet">
</head>>
<body>
	<div class="page light">
		<h1 style="text-align: center;">Софтуерни шаблони. <br>Структурни шаблони в PHP </h1>
		<h2 style="text-align: right;">Изготвил: <a href="https://www.facebook.com/profile.php?id=100006593058357">Антони Стоев</a>, 62152</h2>
		<div class="center">
			<img src ="img\intro.png" class="index_image"></img>
		</div>

		<h2>Съдържание:</h2>
		<ol>
		  <a href="#Цел"><li>Цел</li></a>
		  <a href="#Въведение"><li>Въведение</li></a>
		  <a href="#Какво са"><li>Какво са структурните софтуерни шаблони в PHP</li></a>
		  <a href="#Примери"><li>Примери за структурни софтуерни шаблони в PHP</li></a>
		  <a href="#Adapter"><li>Adapter
		  	<ol>
		  		<a href="#Adapter problem"><li>Проблем</li></a>
		  		<a href="#Adapter solution"><li>Решение</li></a>
		  		<a href="#Adapter code"><li>Концептуален пример с код на PHP</li></a>
		  		<a href="#Adapter pros and cons"><li>Предимства и недостатъци</li></a>
		  	</ol>
		   </li></a>
		   <a href="#Decorator"><li>Decorator
		    	<ol>
		  		<a href="#Decorator problem"><li>Проблем</li></a>
		  		<a href="#Decorator solution"><li>Решение</li></a>
		  		<a href="#Decorator code"><li>Концептуален пример с код на PHP</li></a>
		  		<a href="#Decorator pros and cons"><li>Предимства и недостатъци</li></a>
		  		</ol>
		    </li></a>
		    <a href="#Literature"><li>Цитирана литература</li></a>
		</ol> 

		<h2 id="Цел">1. Цел</h2>
			<p>Следната html страница представлява реферат за задължителната учебна дисциплина WEB технологии, изучавана във ФМИ, Софийски Университет „Климент Охридски“. 
			<br>Рефератът е на тема: „Софтуерни шаблони; структурни (в php)“, избрана по случаен начин. Целта е да се даде информация за това какво представляват стуктурните софтуерни шаблони в езика PHP, като за написването на реферата се прилагат технологиите, изучавани в курса. 
			</p>

		<h2 id="Въведение">2. Въведение</h2>
			<p>Има множество начини как да структурираме кода си, каква архитектура да използваме и по какъв начин да я имплементираме. Но обикновено е добра идея да използваме готови шаблони, които да следваме. Именно това са софтуерните шаблони. 
			<br>Те са една от основните абстракции в програмирането и познаването им би било изключително ползотворно. Софтуерните шаблони, известни още като дизайн шаблони (Design patterns), представляват преизползваеми решения на често срещани проблеми. Те не са чист код, а по-скоро начин, подход към даден проблем. Най-общо шаблоните се разделят на 3 групи, в зависимост от това каква задача изпълняват:
			</p>
		<ul>
		  <li>Шаблони за създаване (Creational patterns)</li>
		  <li>Структурни шаблони (Structural patterns)</li>
		  <li>Шаблони за поведение (Behavioral patterns)</li>
		</ul> 

		<h2 id="Какво са">3. Какво са структурните софтуерни шаблони в PHP</h2>
			<p>Основната задача на структурните дизайн шаблони е да улеснят разбирането на връзките между компонентите в системата. В зависимост от целта, има различни подходи.</p>

		<h2 id="Примери">4. Примери за структурни шаблони:</h2>
		<ul>
		  <a href="#Adapter"><li>Adapter</li></a>
		  <li>Bridge</li>
		  <li>Composite</li>
		  <a href="#Decorator"><li>Decorator</li></a>
		  <li>Facade</li>
		  <li>Flywiehgt</li>
		  <li>Proxy</li>  
		</ul> 

		<h2 id="Adapter">5. Adapter</h2>
			<p>Adapter е един от най-популярните структурни шаблони. Той позволява обекти, с несъчетаеми интерфейси да взаимодействат помежду си.</p>

			<p id="Adapter problem"><b>5.1. Проблем</b></p>

				<div>
					<p>Представете си, че имате приложение, което взима данни от борсовия пазар в XML формат и представя на потребителите таблици и диаграми.
					<br>В даден момент решавате, че може да използвате библиотека за анализ на данни, с което да подобрите приложението. Възниква следният проблем, приложението получава информацията в XML формат, а библиотеката, която искате да внедрите работи с JSON формат. 
					</p>
				</div>
				
				<div class="center">
					<img src="img\adapter-problem.png"></img>
				</div>

			<p id="Adapter solution"><b>5.2. Решение</b></p>
				<p>Възможно е просто да промените библиотеката да работи с XML формат, но това не гарантира, че в процеса на промяна няма да се „счупи“ нещо в кода, а и доста често кодът на такива библиотеки (3-rd party) е скрит и нямате достъп до него.<br>
			Стандартно решение в тази ситуация е просто да се направи adapter. Това представлява специален обект, който конвертира интерфейса на даден обект, за да може друг обект да го използва. Чрез използването на адаптер се вдига нивото на абстракция в системата. Важно е, че обектът, обвит от адаптера, може дори да не знае за съществуването му. Например имате обект, работещ в мерни единици – метри и километри, а адаптера, който го конвертира променя данните във футове и мили.</p>
				<p>Ето и как работи адаптерът:</p>
				<ol>
					<li>Адаптерът приема интерфейс, съвместим с един от съществуващите обекти</li>
					<li>Чрез този интерфейс, обектът се свързва с адаптера, извиквайки негов метод</li>
					<li>След извикване на метода, адаптерът предава заявката на другия обект, в очаквания от него формат</li>
				</ol>
				<p>Възможно е да се направи 2-посочен адаптер, ако е необходимо конвертиране на информацията в двете посоки.</p>

				<div class="center">
					<img src="img\adapter-solution.png"></img>
				</div>	
			<p id="Adapter code"><b>5.3. Концептуален пример с код на PHP</b></p>

			<img src="img\adapter-code-part-1.png" class="center"></img>
			
			
			
			<img src="img\adapter-code-part-2.png" class="center"></img>
			
			
			<img src="img\adapter-code-part-3.png" class="center"></img>
			
			<div class="center">
				<p><b>Output:</b></p>
				<img src="img\adapter-output.png"></img>
			</div>
			<p id="Adapter pros and cons"><b>5.4 Предимства и недостатъци</b></p>
				<p>+ Запазване на Single Responsinility Principle. Може да се раздели интерфейсът или кодът за конвертиране на данни от бизнес логиката.</p>
				<p>+ Запазване на Open/Closed Principle. Може да се добавят нови адаптери, без това да счупи системата.</p>
				<p>- Цялостната сложност на системата се увеличава заради добавянето на нови класове и интерфейси. Понякога е по-лесно просто да се промени даден клас, а не да се прави адаптер за него.</p>
			
		<h2 id="Decorator"><b>6. Decorator</b></h2>
			<p>Друг често използван софтуерен шаблон е Decorator. Употребата на този дизайн позволява да се добавя ново поведение към обекти, като тези обекти се поставят в специални обващащи обекти (wrapper objects), които дефинират новото поведение.</p>
			<p id="Decorator problem"><b>6.1. Проблем</b></p>
				<p>Представете си, че работите над библиотека свързана с изпращане на нотификации, която позволява на други програми да изпращат съобщение до своите потребители.
			Първоначално се спирате на клас Notifier, който е с доста проста архитектура – констуктор и метод, който изпраща съобщение.
			</p>
				<p>В даден момент решавате, че искате да направите библиотеката да работи  не само с имейли, но също и с SMS-и, Slack съобщения, Facebooк нотификации.
			Наивният подход дава следното решение – създаване на нови класове, наследяващи базовия Notifier.
			</p>
				<img src="img\decorator-problem.png" class="center"></img>
				<p>Добре, но в един момент идва клиент и ви казва, че когато е наложащо, е хубаво да се изпращат съобщения по всички канали или комбинации от тях, например, ако къщата гори, трябва да се изпратят съобщения по мейл, SMS, Slack, Facebook.</p>
				<p>Решението – създаваме още класове:</p>
				<img src="img\decorator-problem_2.png" class="center"></img>
				<p>Това решение не е много подходящо, защото класовете стават прекалено много, ако трябва да търсим всяка комбинация</p>
			<p id="Decorator solution"><b>6.2.	Решение</b></p>
				<p>Decorator шаблонът дава необходимото решение за този проблем. Декораторът всъщност обхваща поведението на даден клас, той имплементира същото поведение. Поведението да се изпрати нотификация от клиентска гледна точка е едно и също, независимо дали се изпраща чрез мейл, SMS, Slack, Facebook. Затова могат да се създадат определени декоратори, които изпълняват това поведение, но по определен начин.</p>
				<img src="img\decorator-hierarchy.png" class="center"></img>
				<p>По този начин видът на съобщението се избира чрез wrap-ване с определeн декоратор.</p>
				<img src="img\decorator-stack.png"class="center"></img>
				<p>Последният декоратор в стека всъщност ще е точно този, с който клиентът иска да работи.</p>
				<p>Ето и как работи декораторът:</p>
				<img src="img\decorator-work-structure.png" class="center"></img>
				<ol>
					<li>Компонентът (Component) декларира общ интерфейс за обхванатия (wrapped object) и обхващащия(wrapper) обекти</li>
					<li>Конкретен компонент (Concrete Component) е клас от обвхванати обекти(декорирани). Той описва основното поведение, което се ползва и от декораторите.</li>
					<li>Базовият Декоратор (Base Decorator) клас има поле, което реферира към wrapped обект. Базовият декоратор изпраща операциите до обхванатия обект.</li>
					<li>Конкретни Декоратори (Concrete Decorators) дефинират допълнително поведение, което може да се добавя към компонентите динамично. Конкретните декоратори предефинират (override) методи от Базовия Декоратор и изпълняват своето поведение или преди или след извикване на бащиния метод.</li>
					<li>Клиентът (Client) може да обхваща (wrap) компоненти в множество слоеве от декоратори, докато процесът работи с всички обекти през интерфейса на компонент.</li>
				</ol>

			<p id="Decorator code"><b>6.3 Концептуален пример с код на PHP</b></p>
				<img src="img\decorator-code-part-1.png" class="center"></img>
				<img src="img\decorator-code-part-2.png" class="center"></img>
				<img src="img\decorator-code-part-3.png" class="center"></img>
				<img src="img\decorator-code-part-4.png" class="center"></img>
				<p class="center"><b>Output:</b></p>
				<img src="img\decorator-output.png" class="center"></img>

			<p id="Decorator pros and cons"><b>6.4 Предимства и недостатъци</b></p>
				<p>+ Подобрява(в смисъла на Extend) поведението на даден обект без да добавя нови класове наследници.</p>
				<p>+ Може да се добавят или премахват задължения на обект повреме на изпълнение (runtime).</p>
				<p>+ Може да се добавят множество поведения като се обхване обект от множество декоратори (Както в примера с нотификациите).</p>
				<p>+ Запазване и прилагане на Single Responsibility Principle.</p>
				<p>- Трудно се премахва даден декоратор от стека на декораторите</p>
				<p>- Трудно се имплементира декоратор, по такъв начин, по който той да не зависи от реда в стека</p>
		<h2 id="Literature"><b>Цитирана литература</b></h2>
			<ul>
				<li>[1] Design patterns in PHP, <a href="https://refactoring.guru/design-patterns/php">[https://refactoring.guru/design-patterns/php]</a>, последно посетен на 2020-04-08</li>
				<li>[2] Design patterns, <a href="https://phptherightway.com/pages/Design-Patterns.html">[https://phptherightway.com/pages/Design-Patterns.html]</a>, последно посетен на 2020-04-08</li>
				<li>[3] Software design patterns, <a href="https://en.wikipedia.org/wiki/Software_design_pattern">[https://en.wikipedia.org/wiki/Software_design_pattern]</a>, последно посетен на 2020-04-08</li>
				<li>[4] Structural design patterns, <a href="https://designpatternsphp.readthedocs.io/en/latest/Structural/README.html">[https://designpatternsphp.readthedocs.io/en/latest/Structural/README.html]</a>, последно посетен на 2020-04-08</li>
				<li>[5] Adapter, <a href="https://refactoring.guru/design-patterns/adapter">[https://refactoring.guru/design-patterns/adapter]</a>, последно посетен на 2020-04-08</li>
				<li>[6] Adapter - Conceptual example, <a href="https://refactoring.guru/design-patterns/adapter/php/example#lang-features">[https://refactoring.guru/design-patterns/adapter/php/example#lang-features]</a>, последно посетен на 2020-04-09</li>
				<li>[7] Decorator, <a href="https://refactoring.guru/design-patterns/decorator">[https://refactoring.guru/design-patterns/decorator]</a>, последно посетен на 2020-04-08</li>
				<li>[8] Decorator - Conceptual example, <a href="https://refactoring.guru/design-patterns/command/php/example#lang-features">[https://refactoring.guru/design-patterns/command/php/example#lang-features]</a>, последно посетен на 2020-04-09</li>
			</ul>
	</div>
</body>
</html>
